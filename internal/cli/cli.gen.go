// Package cli provides primitives to interact with the Open CLI Spec-Compliant CLI.
//
// Code generated by ocli-codegen DO NOT EDIT.
package cli

import (
  "context"

  urfavecli "github.com/urfave/cli/v3"
)

func New(impl CLIHandlersInterface, version string) *urfavecli.Command {

  ocliCmd := &urfavecli.Command{}
  ocliGenerateCmd := &urfavecli.Command{}
  ocliGenerateCliCmd := &urfavecli.Command{}
  ocliGenerateDocsCmd := &urfavecli.Command{}
  ocliSpecificationCmd := &urfavecli.Command{}
  ocliSpecificationCheckCmd := &urfavecli.Command{}
  ocliSpecificationVersionsCmd := &urfavecli.Command{}


  ocliCmd.Name = "ocli"
  ocliCmd.UsageText = "ocli {command} <arguments> [flags]"
  ocliCmd.Usage = "A CLI for working with OpenCLI Specs"
  ocliCmd.Commands = []*urfavecli.Command{
    ocliGenerateCmd,
    ocliSpecificationCmd,
  }


  ocliGenerateCmd.Name = "generate"
  ocliGenerateCmd.UsageText = "ocli generate {command} <arguments> [flags]"
  ocliGenerateCmd.Usage = "Commands used to generate code and/or documentation from an OpenCLI Spec document"
  ocliGenerateCmd.Aliases = []string{
    "gen",
  }
  ocliGenerateCmd.Commands = []*urfavecli.Command{
    ocliGenerateCliCmd,
    ocliGenerateDocsCmd,
  }


  ocliGenerateCliCmd.Name = "cli"
  ocliGenerateCliCmd.UsageText = "ocli generate cli <path-to-spec> <path-to-output-dir> [flags]"
  ocliGenerateCliCmd.Usage = "Generate CLI Boilerplate code from an OpenCLI Spec document"
  ocliGenerateCliCmd.Flags = []urfavecli.Flag{
    &urfavecli.StringFlag{
      Name: "framework",
      Usage: "The framework of the CLI boilerplate to generate",
      Aliases: []string{
        "f",
      },
    },
    &urfavecli.StringFlag{
      Name: "package",
      Usage: "The package name used to house the generated code",
      Value: "cli",
    },
    &urfavecli.BoolFlag{
      Name: "dryrun",
      Usage: "When true the docs contents will be output to stdout instead of the file",
      Value: true,
    },
  }
  ocliGenerateCliCmd.Action = func(ctx context.Context, cmd *urfavecli.Command) error {
    var validChoice bool
    var args OcliGenerateCliArgs
    if cmd.NArg() < 1 {
      return urfavecli.Exit("missing required arg <path-to-spec>", 2)
    }
    args.PathToSpec = cmd.Args().Get(0)
    if cmd.NArg() < 2 {
      return urfavecli.Exit("missing required arg <path-to-output-dir>", 2)
    }
    args.PathToOutputDir = cmd.Args().Get(1)
    
    var flags OcliGenerateCliFlags
    flags.Framework = cmd.String("framework")
    if !cmd.IsSet("framework") {
      return urfavecli.Exit("missing required flag --framework", 2)
    }
    validChoice = validateChoices(
      []string{
        "cobra",
        "urfavecli",
        "yargs",
        "oclif",
      },
      flags.Framework,
    )
    if !validChoice {
      return urfavecli.Exit("invalid value for flag --framework", 2)
    }
    flags.Package = cmd.String("package")
    if !cmd.IsSet("package") {
      return urfavecli.Exit("missing required flag --package", 2)
    }
    flags.Dryrun = cmd.Bool("dryrun")

    return impl.OcliGenerateCli(ctx, cmd, args, flags)
  }


  ocliGenerateDocsCmd.Name = "docs"
  ocliGenerateDocsCmd.UsageText = "ocli generate docs <path-to-spec> <path-to-output-dir> [flags]"
  ocliGenerateDocsCmd.Usage = "Generate documentation from an OpenCLI Spec document"
  ocliGenerateDocsCmd.Flags = []urfavecli.Flag{
    &urfavecli.StringFlag{
      Name: "format",
      Usage: "The format of the documentation to generate",
      Aliases: []string{
        "f",
      },
    },
    &urfavecli.BoolFlag{
      Name: "dryrun",
      Usage: "When true the docs contents will be output to stdout instead of the file",
      Value: true,
    },
  }
  ocliGenerateDocsCmd.Action = func(ctx context.Context, cmd *urfavecli.Command) error {
    var validChoice bool
    var args OcliGenerateDocsArgs
    if cmd.NArg() < 1 {
      return urfavecli.Exit("missing required arg <path-to-spec>", 2)
    }
    args.PathToSpec = cmd.Args().Get(0)
    if cmd.NArg() < 2 {
      return urfavecli.Exit("missing required arg <path-to-output-dir>", 2)
    }
    args.PathToOutputDir = cmd.Args().Get(1)
    
    var flags OcliGenerateDocsFlags
    flags.Format = cmd.String("format")
    if !cmd.IsSet("format") {
      return urfavecli.Exit("missing required flag --format", 2)
    }
    validChoice = validateChoices(
      []string{
        "markdown",
        "html",
        "man",
      },
      flags.Format,
    )
    if !validChoice {
      return urfavecli.Exit("invalid value for flag --format", 2)
    }
    flags.Dryrun = cmd.Bool("dryrun")

    return impl.OcliGenerateDocs(ctx, cmd, args, flags)
  }


  ocliSpecificationCmd.Name = "specification"
  ocliSpecificationCmd.UsageText = "ocli specification {command} <arguments> [flags]"
  ocliSpecificationCmd.Usage = "Commands related to the OpenCLI Specification"
  ocliSpecificationCmd.Aliases = []string{
    "spec",
    "sp",
  }
  ocliSpecificationCmd.Commands = []*urfavecli.Command{
    ocliSpecificationCheckCmd,
    ocliSpecificationVersionsCmd,
  }


  ocliSpecificationCheckCmd.Name = "check"
  ocliSpecificationCheckCmd.UsageText = "ocli specification check <path-to-spec>"
  ocliSpecificationCheckCmd.Usage = "Check an OpenCLI Spec document for errors"
  ocliSpecificationCheckCmd.Action = func(ctx context.Context, cmd *urfavecli.Command) error {
    var args OcliSpecificationCheckArgs
    if cmd.NArg() < 1 {
      return urfavecli.Exit("missing required arg <path-to-spec>", 2)
    }
    args.PathToSpec = cmd.Args().Get(0)

    return impl.OcliSpecificationCheck(ctx, cmd, args)
  }


  ocliSpecificationVersionsCmd.Name = "versions"
  ocliSpecificationVersionsCmd.UsageText = "ocli specification versions"
  ocliSpecificationVersionsCmd.Usage = "Print the versions of the OpenCLI Specificatons that are supported"
  ocliSpecificationVersionsCmd.Action = func(ctx context.Context, cmd *urfavecli.Command) error {

    return impl.OcliSpecificationVersions(ctx, cmd)
  }



  ocliCmd.Version = version
  return ocliCmd
}
