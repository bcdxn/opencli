// Package cli provides primitives to interact with the Open CLI Spec-Compliant CLI.
//
// Code generated by ocli-codegen DO NOT EDIT.
package cli

import (
  "context"
  
  altsrc "github.com/urfave/cli-altsrc/v3"
  urfavecli "github.com/urfave/cli/v3"
)

func New(impl CLIHandlersInterface, version string) *urfavecli.Command {

  ocliCmd := &urfavecli.Command{}
  ocliGenerateCmd := &urfavecli.Command{}
  ocliGenerateCliCmd := &urfavecli.Command{}
  ocliGenerateDocsCmd := &urfavecli.Command{}
  ocliSpecificationCmd := &urfavecli.Command{}
  ocliSpecificationCheckCmd := &urfavecli.Command{}
  ocliSpecificationVersionsCmd := &urfavecli.Command{}

	ocliCmd.Name = "ocli"
	ocliCmd.UsageText = "ocli {command} <arguments> [flags]"
	ocliCmd.Usage = "A CLI for working with OpenCLI Specs"
	ocliCmd.Commands = []*urfavecli.Command{
		ocliGenerateCmd,
		ocliSpecificationCmd,
	}

	ocliGenerateCmd.Name = "generate"
	ocliGenerateCmd.UsageText = "ocli generate {command} [flags]"
	ocliGenerateCmd.Usage = "Commands used to generate code/docs from an OpenCLI Spec document"
	ocliGenerateCmd.Aliases = []string{
		"gen",
	}
	ocliGenerateCmd.Commands = []*urfavecli.Command{
		ocliGenerateCliCmd,
		ocliGenerateDocsCmd,
	}

	ocliGenerateCliCmd.Name = "cli"
	ocliGenerateCliCmd.UsageText = "ocli generate cli [flags]"
	ocliGenerateCliCmd.Usage = "Generate CLI Boilerplate code from an OpenCLI Spec document"
	ocliGenerateCliCmd.Flags = []urfavecli.Flag{
		&urfavecli.StringFlag{
			Name: "spec-file",
			Usage: "The path to the OpenCLI Spec that code will be generated from",
			Aliases: []string{
				"s",
			},
			Hidden: false,
		},
		&urfavecli.StringFlag{
			Name: "output-dir",
			Usage: "The path to the directory where the generated code will be output",
			Aliases: []string{
				"o",
			},
			Hidden: false,
		},
		&urfavecli.StringFlag{
			Name: "framework",
			Usage: "The framework of the CLI boilerplate to generate",
			Aliases: []string{
				"f",
			},
			Sources: urfavecli.NewValueSourceChain(
				urfavecli.EnvVar("OCLI_CLI_FRAMEWORK"),
				altsrc.YAML("cli.framework", "~/.ocli/config.yaml").Chain[0],
			),
			Hidden: false,
		},
		&urfavecli.StringFlag{
			Name: "go-package",
			Usage: "The package name used to house the generated code; required for go frameworks.",
			Value: "cli",
			Sources: urfavecli.NewValueSourceChain(
				urfavecli.EnvVar("OCLI_CLI_GO_PACKAGE"),
				altsrc.YAML("cli.go_package", "~/.ocli/config.yaml").Chain[0],
			),
			Hidden: false,
		},
		&urfavecli.StringFlag{
			Name: "module-type",
			Usage: "Indicates the module type of the generated code; required when generating a yargs CLI.",
			Sources: urfavecli.NewValueSourceChain(
				urfavecli.EnvVar("OCLI_CLI_MODULE_TYPE"),
				altsrc.YAML("cli.module_type", "~/.ocli/config.yaml").Chain[0],
			),
			Hidden: false,
		},
		&urfavecli.BoolFlag{
			Name: "dryrun",
			Usage: "When true the CLI code contents will be output to stdout instead of the file",
			Value: true,
			Hidden: false,
		},
	}
  ocliGenerateCliCmd.Action = func(ctx context.Context, cmd *urfavecli.Command) error {
   
    
    
		var flags OcliGenerateCliFlags
		flags.SpecFile = cmd.String("spec-file")
		flags.OutputDir = cmd.String("output-dir")
		flags.Framework = cmd.String("framework")
		flags.GoPackage = cmd.String("go-package")
		flags.ModuleType = cmd.String("module-type")
		flags.Dryrun = cmd.Bool("dryrun")
		if !cmd.IsSet("spec-file") {
			return urfavecli.Exit("missing required flag --spec-file", 2)
		}
		if !cmd.IsSet("output-dir") {
			return urfavecli.Exit("missing required flag --output-dir", 2)
		}
		if !cmd.IsSet("framework") {
			return urfavecli.Exit("missing required flag --framework", 2)
		}

		var validFlagChoice bool
		validFlagChoice = validateChoices(
			[]string{
				"urfavecli",
				"yargs",
			},
			flags.Framework,
		)
		if !validFlagChoice {
			return urfavecli.Exit("invalid value for flag --framework", 2)
		}
		validFlagChoice = validateChoices(
			[]string{
				"cjs",
				"",
			},
			flags.ModuleType,
		)
		if !validFlagChoice {
			return urfavecli.Exit("invalid value for flag --module-type", 2)
		}

    return impl.OcliGenerateCli(ctx, cmd, flags)
  }

	ocliGenerateDocsCmd.Name = "docs"
	ocliGenerateDocsCmd.UsageText = "ocli generate docs [flags]"
	ocliGenerateDocsCmd.Usage = "Generate documentation from an OpenCLI Spec document"
	ocliGenerateDocsCmd.Flags = []urfavecli.Flag{
		&urfavecli.StringFlag{
			Name: "spec-file",
			Usage: "The path to the OpenCLI Spec that documentation will be generated from",
			Aliases: []string{
				"s",
			},
			Hidden: false,
		},
		&urfavecli.StringFlag{
			Name: "output-dir",
			Usage: "The path to the directory where the generated docs will be output",
			Aliases: []string{
				"o",
			},
			Hidden: false,
		},
		&urfavecli.StringFlag{
			Name: "format",
			Usage: "The format of the documentation to generate",
			Aliases: []string{
				"f",
			},
			Sources: urfavecli.NewValueSourceChain(
				urfavecli.EnvVar("OCLI_DOCS_FORMAT"),
				altsrc.YAML("docs.format", "~/.ocli/config.yaml").Chain[0],
			),
			Hidden: false,
		},
		&urfavecli.BoolFlag{
			Name: "footer",
			Usage: "Include the footer in the docs",
			Value: true,
			Sources: urfavecli.NewValueSourceChain(
				urfavecli.EnvVar("OCLI_DOCS_FOOTER"),
				altsrc.YAML("docs.footer", "~/.ocli/config.yaml").Chain[0],
			),
			Hidden: false,
		},
		&urfavecli.BoolFlag{
			Name: "dryrun",
			Usage: "When true the docs contents will be output to stdout instead of the file",
			Value: true,
			Hidden: false,
		},
	}
  ocliGenerateDocsCmd.Action = func(ctx context.Context, cmd *urfavecli.Command) error {
   
    
    
		var flags OcliGenerateDocsFlags
		flags.SpecFile = cmd.String("spec-file")
		flags.OutputDir = cmd.String("output-dir")
		flags.Format = cmd.String("format")
		flags.Footer = cmd.Bool("footer")
		flags.Dryrun = cmd.Bool("dryrun")
		if !cmd.IsSet("spec-file") {
			return urfavecli.Exit("missing required flag --spec-file", 2)
		}
		if !cmd.IsSet("output-dir") {
			return urfavecli.Exit("missing required flag --output-dir", 2)
		}
		if !cmd.IsSet("format") {
			return urfavecli.Exit("missing required flag --format", 2)
		}

		var validFlagChoice bool
		validFlagChoice = validateChoices(
			[]string{
				"markdown",
			},
			flags.Format,
		)
		if !validFlagChoice {
			return urfavecli.Exit("invalid value for flag --format", 2)
		}

    return impl.OcliGenerateDocs(ctx, cmd, flags)
  }

	ocliSpecificationCmd.Name = "specification"
	ocliSpecificationCmd.UsageText = "ocli specification {command} <arguments> [flags]"
	ocliSpecificationCmd.Usage = "Commands related to the OpenCLI Specification"
	ocliSpecificationCmd.Aliases = []string{
		"spec",
	}
	ocliSpecificationCmd.Commands = []*urfavecli.Command{
		ocliSpecificationCheckCmd,
		ocliSpecificationVersionsCmd,
	}

	ocliSpecificationCheckCmd.Name = "check"
	ocliSpecificationCheckCmd.UsageText = "ocli specification check <path-to-spec>"
	ocliSpecificationCheckCmd.Usage = "Check an OpenCLI Spec document for errors"
  ocliSpecificationCheckCmd.Action = func(ctx context.Context, cmd *urfavecli.Command) error {
   
    
		var args OcliSpecificationCheckArgs
		if cmd.NArg() < 1 {
			return urfavecli.Exit("missing required arg <path-to-spec>", 2)
		}
		args.PathToSpec = cmd.Args().Get(0)
    

    return impl.OcliSpecificationCheck(ctx, cmd, args)
  }

	ocliSpecificationVersionsCmd.Name = "versions"
	ocliSpecificationVersionsCmd.UsageText = "ocli specification versions"
	ocliSpecificationVersionsCmd.Usage = "Print the versions of the OpenCLI Specifications that are supported"
  ocliSpecificationVersionsCmd.Action = func(ctx context.Context, cmd *urfavecli.Command) error {
   
    
    

    return impl.OcliSpecificationVersions(ctx, cmd)
  }



  ocliCmd.Version = version
  return ocliCmd
}
